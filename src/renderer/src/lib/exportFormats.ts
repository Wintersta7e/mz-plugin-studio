// Export format generators for MZ Plugin Studio
// Generates plugins.json entries, TypeScript declarations, and README files

import type { PluginDefinition, PluginParameter, ParamType } from '../types/plugin'

/**
 * Generates a JSON entry for plugins.js
 * Creates the object structure that RPG Maker expects in the plugins.js file
 */
export function generatePluginsJsonEntry(plugin: PluginDefinition): string {
  const parameters: Record<string, string> = {}

  // Map each parameter name to its string default value
  for (const param of plugin.parameters) {
    // Skip nested parameters (they're handled by their parent struct)
    if (param.parent) continue

    parameters[param.name] = String(param.default)
  }

  const entry = {
    name: plugin.meta.name,
    status: true,
    description: plugin.meta.description,
    parameters
  }

  return JSON.stringify(entry, null, 2)
}

/**
 * Converts a parameter type to TypeScript type
 */
function paramTypeToTS(type: ParamType): string {
  switch (type) {
    case 'number':
    case 'variable':
    case 'switch':
    case 'actor':
    case 'class':
    case 'skill':
    case 'item':
    case 'weapon':
    case 'armor':
    case 'enemy':
    case 'troop':
    case 'state':
    case 'animation':
    case 'tileset':
    case 'common_event':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'struct':
      return 'Record<string, unknown>'
    case 'array':
      return 'unknown[]'
    default:
      return 'string'
  }
}

/**
 * Generates a TypeScript declaration file (.d.ts) for the plugin
 */
export function generateTypeDeclaration(plugin: PluginDefinition): string {
  const lines: string[] = []

  lines.push(`// Type declarations for ${plugin.meta.name} v${plugin.meta.version}`)
  lines.push(`// Generated by MZ Plugin Studio`)
  lines.push(``)
  lines.push(`declare namespace ${plugin.meta.name} {`)

  // Generate Parameters interface if there are parameters
  if (plugin.parameters.length > 0) {
    lines.push(`  interface Parameters {`)
    for (const param of plugin.parameters) {
      // Skip nested parameters
      if (param.parent) continue

      const description = param.desc || param.text
      lines.push(`    /** ${description} */`)
      lines.push(`    ${param.name}: ${paramTypeToTS(param.type)}`)
    }
    lines.push(`  }`)
    lines.push(``)
  }

  // Generate command arg interfaces
  for (const command of plugin.commands) {
    if (command.args.length === 0) continue

    lines.push(`  interface ${command.name}Args {`)
    for (const arg of command.args) {
      const description = arg.desc || arg.text
      lines.push(`    /** ${description} */`)
      lines.push(`    ${arg.name}: ${paramTypeToTS(arg.type)}`)
    }
    lines.push(`  }`)
    lines.push(``)
  }

  lines.push(`}`)

  return lines.join('\n')
}

/**
 * Generates a README.md file for the plugin
 */
export function generateReadme(plugin: PluginDefinition): string {
  const lines: string[] = []

  // Title
  lines.push(`# ${plugin.meta.name}`)
  lines.push(``)

  // Version/Author/Target
  lines.push(
    `**Version:** ${plugin.meta.version} | **Author:** ${plugin.meta.author} | **Target:** ${plugin.meta.target}`
  )
  lines.push(``)

  // Description
  if (plugin.meta.description) {
    lines.push(`> ${plugin.meta.description}`)
    lines.push(``)
  }

  // Installation
  lines.push(`## Installation`)
  lines.push(``)
  lines.push(`1. Download \`${plugin.meta.name}.js\``)
  lines.push(`2. Place it in your project's \`js/plugins/\` folder`)
  lines.push(`3. Enable it in the Plugin Manager`)
  lines.push(``)

  // Dependencies
  if (plugin.meta.dependencies.length > 0 || plugin.meta.orderAfter?.length) {
    lines.push(`## Dependencies`)
    lines.push(``)
    if (plugin.meta.dependencies.length > 0) {
      lines.push(`**Required plugins:**`)
      for (const dep of plugin.meta.dependencies) {
        lines.push(`- ${dep}`)
      }
      lines.push(``)
    }
    if (plugin.meta.orderAfter && plugin.meta.orderAfter.length > 0) {
      lines.push(`**Load order:** Must be placed after:`)
      for (const order of plugin.meta.orderAfter) {
        lines.push(`- ${order}`)
      }
      lines.push(``)
    }
  }

  // Parameters
  const topLevelParams = plugin.parameters.filter((p) => !p.parent)
  if (topLevelParams.length > 0) {
    lines.push(`## Parameters`)
    lines.push(``)
    lines.push(`| Parameter | Type | Default | Description |`)
    lines.push(`|-----------|------|---------|-------------|`)
    for (const param of topLevelParams) {
      const typeStr = param.type === 'select' ? 'select' : param.type
      const defaultStr = String(param.default)
      const descStr = param.desc || param.text
      lines.push(`| ${param.text} | ${typeStr} | ${defaultStr} | ${descStr} |`)
    }
    lines.push(``)
  }

  // Plugin Commands
  if (plugin.commands.length > 0) {
    lines.push(`## Plugin Commands`)
    lines.push(``)

    for (const command of plugin.commands) {
      lines.push(`### ${command.text}`)
      lines.push(``)
      if (command.desc) {
        lines.push(command.desc)
        lines.push(``)
      }

      if (command.args.length > 0) {
        lines.push(`**Arguments:**`)
        lines.push(``)
        lines.push(`| Argument | Type | Description |`)
        lines.push(`|----------|------|-------------|`)
        for (const arg of command.args) {
          const typeStr = arg.type
          const descStr = arg.desc || arg.text
          lines.push(`| ${arg.text} | ${typeStr} | ${descStr} |`)
        }
        lines.push(``)
      }
    }
  }

  // Help text
  if (plugin.meta.help) {
    lines.push(`## Additional Information`)
    lines.push(``)
    lines.push(plugin.meta.help)
    lines.push(``)
  }

  // URL
  if (plugin.meta.url) {
    lines.push(`## More Information`)
    lines.push(``)
    lines.push(plugin.meta.url)
    lines.push(``)
  }

  // Footer
  lines.push(`---`)
  lines.push(``)
  lines.push(`*Generated by [MZ Plugin Studio](https://github.com/Wintersta7e/mz-plugin-studio)*`)

  return lines.join('\n')
}

/**
 * Format parameter type with constraints for help text display.
 * Examples: "number", "number, min: 0, max: 100", "struct<MyStruct>", "number[]"
 */
function formatParamTypeInfo(param: PluginParameter): string {
  let typeStr = param.type as string

  if (param.type === 'struct' && param.structType) {
    typeStr = 'struct<' + param.structType + '>'
  }
  if (param.type === 'array') {
    if (param.structType) {
      typeStr = 'struct<' + param.structType + '>[]'
    } else if (param.arrayType) {
      typeStr = param.arrayType + '[]'
    } else {
      typeStr = 'string[]'
    }
  }

  const constraints: string[] = []
  if (param.type === 'number') {
    if (param.min !== undefined) constraints.push('min: ' + param.min)
    if (param.max !== undefined) constraints.push('max: ' + param.max)
    if (param.decimals !== undefined) constraints.push('decimals: ' + param.decimals)
  }

  if (constraints.length > 0) {
    typeStr += ', ' + constraints.join(', ')
  }

  return typeStr
}

/**
 * Generates formatted plain-text help content for the @help annotation.
 * Uses ASCII box-drawing for monospace display in MZ's plugin manager.
 */
export function generateHelpText(plugin: PluginDefinition): string {
  const lines: string[] = []
  const SEP_HEAVY = '='.repeat(76)
  const SEP_LIGHT = '-'.repeat(76)

  // Title block
  lines.push(SEP_HEAVY)
  lines.push(' ' + plugin.meta.name + ' v' + plugin.meta.version)
  if (plugin.meta.author) {
    lines.push(' by ' + plugin.meta.author)
  }
  lines.push(SEP_HEAVY)

  // Description
  if (plugin.meta.description) {
    lines.push('')
    lines.push(' ' + plugin.meta.description)
  }

  // Parameters section (only top-level, skip nested/parent and divider params)
  const topLevelParams = plugin.parameters.filter(
    (p) => !p.parent && !p.name.includes('---') && !p.name.includes('===')
  )
  if (topLevelParams.length > 0) {
    lines.push('')
    lines.push(SEP_LIGHT)
    lines.push(' Parameters')
    lines.push(SEP_LIGHT)

    for (const param of topLevelParams) {
      lines.push('')
      const typeInfo = formatParamTypeInfo(param)
      lines.push(' ' + (param.text || param.name) + ' (' + typeInfo + ')')
      if (param.desc) {
        lines.push('   ' + param.desc)
      }
      if (param.default !== undefined && param.default !== '') {
        lines.push('   Default: ' + param.default)
      }
    }
  }

  // Commands section
  if (plugin.commands.length > 0) {
    lines.push('')
    lines.push(SEP_LIGHT)
    lines.push(' Plugin Commands')
    lines.push(SEP_LIGHT)

    for (const cmd of plugin.commands) {
      lines.push('')
      lines.push(' ' + (cmd.text || cmd.name))
      if (cmd.desc) {
        lines.push('   ' + cmd.desc)
      }
      if (cmd.args.length > 0) {
        lines.push('   Arguments:')
        for (const arg of cmd.args) {
          const desc = arg.desc ? ' - ' + arg.desc : ''
          lines.push('     ' + (arg.text || arg.name) + ' (' + arg.type + ')' + desc)
        }
      }
    }
  }

  // Structs section
  if (plugin.structs.length > 0) {
    lines.push('')
    lines.push(SEP_LIGHT)
    lines.push(' Structs')
    lines.push(SEP_LIGHT)

    for (const struct of plugin.structs) {
      lines.push('')
      const fieldList = struct.parameters
        .map((p) => (p.text || p.name) + ' (' + p.type + ')')
        .join(', ')
      lines.push(' ' + struct.name)
      lines.push('   Fields: ' + fieldList)
    }
  }

  // Dependencies section
  const hasDeps = plugin.meta.dependencies.length > 0
  const hasOrderAfter = (plugin.meta.orderAfter || []).length > 0
  if (hasDeps || hasOrderAfter) {
    lines.push('')
    lines.push(SEP_LIGHT)
    lines.push(' Dependencies')
    lines.push(SEP_LIGHT)
    lines.push('')

    if (hasDeps) {
      lines.push(' Required: ' + plugin.meta.dependencies.join(', '))
    }
    if (hasOrderAfter) {
      lines.push(' Load After: ' + plugin.meta.orderAfter!.join(', '))
    }
  }

  // Changelog stub
  lines.push('')
  lines.push(SEP_HEAVY)
  lines.push(' Changelog')
  lines.push(SEP_HEAVY)
  lines.push('')
  lines.push(' v' + plugin.meta.version + ' - Initial release')

  lines.push('')
  lines.push(SEP_HEAVY)

  return lines.join('\n')
}
